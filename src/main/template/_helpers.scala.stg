delimiters "$", "$"

decap(str) ::= <<$str; format="decap"$>>


// Class

wholeClassDef(cls, parent, body) ::= <<
$richClassDef(...)$

$concreteClassDef(cls)$

$companionObjectDef(...)$
>>



openRichClassDef(cls, parent, body) ::= <<$_openRichClassDef(cls.simpleName, parent, body)$>>
_openRichClassDef(name, parent, body) ::= <<
class Rich$name$[V <: $name$](val basis: V) extends Trait$name$[V]
@inline implicit def $decap(name)$2Rich$name$[V <: $name$]($decap(name)$: V) = new Rich$name$[V]($decap(name)$)

trait Trait$name$[V <: $name$]$if(parent)$ extends $parent$$endif$ {
>>

closeRichClassDef(cls) ::= <<
  $properties(cls)$
  $listeners(cls)$
}
>>

richClassDef(cls, parent) ::= <<
$openRichClassDef(...)$
$closeRichClassDef(...)$
>>

withPrefix(name) ::= "S$name$"

openConcreteClassDef(cls) ::= <<$_openConcreteClassDef(cls.simpleName, withPrefix(cls.simpleName))$>>
_openConcreteClassDef(name, prefixedName) ::= <<
class $prefixedName$(implicit context: Context, parentVGroup: TraitViewGroup[_] = null)
    extends $name$(context) with Trait$name$[$prefixedName$] {

  def basis = this

  override val parentViewGroup = parentVGroup

>>


closeConcreteClassDef() ::= "}"

concreteClassDef(cls) ::= <<
$openConcreteClassDef(cls)$
$closeConcreteClassDef()$
>>


// Object

companionObjectDef(cls) ::= <<$_companionObjectDef(cls, cls.simpleName, withPrefix(cls.simpleName))$>>
_companionObjectDef(cls, name, prefixedName) ::= <<
object $prefixedName$ {

  def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]]()
      (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ = {
    val v = (new $prefixedName$)
    v.<<.parent.+=(v)
    v
  }

  $if(cls.isA.TextView)$$textViewConstructor(...)$$endif$

  $if(cls.isA.Button)$$buttonConstructors(...)$$endif$

}
>>

textViewConstructor(cls, name, prefixedName) ::= <<
def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]](txt: CharSequence)
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ =  {
  val v = (new $prefixedName$)
  v text txt
  v.<<.parent.+=(v)
  v
}  
>>

buttonConstructors(cls, name, prefixedName) ::= <<
def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]](text: CharSequence, onClickListener: (View) => Unit)
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ = {
  apply(text, func2ViewOnClickListener(onClickListener))
}

def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]](text: CharSequence, onClickListener: OnClickListener = {})
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ = {
  val v = (new $prefixedName$)
  v.text = text
  v.setOnClickListener(onClickListener)
  v.<<.parent.+=(v)
  v
}
>>


// Listener

paramTypes(types) ::= "($types; separator=\", \"$)"

params(types) ::= "$types:{ t | p$i$: $t$}; separator=\", \"$"

callParams(types) ::= "$types:{ t | p$i$}; separator=\", \"$"

callbackBody(method, isUnit = false) ::= <%
$if(method.hasBody)$
  $if(isUnit)$
    f
  $else$
    f($callParams(method.paramTypes)$)
  $endif$
$endif$
%>

callbackMethod(method, isUnit = false) ::= <<
def $method.name$($params(method.paramTypes)$): $method.retType$ = { $callbackBody(...)$ }
>>

unitCallbackMethod(method) ::= <<$callbackMethod(method, true)$>>

fullListener(l) ::= <<
@inline def $l.name$(f: $paramTypes(l.paramTypes)$ => $l.retType$): V = {
  basis.$l.setter$(new $l.callbackClassName$ {
    $l.callbackMethods:callbackMethod(); separator="\n"$
  })
  basis
}
>>

unitListener(l) ::= <<
@inline def $l.name$(f: => $l.retType$): V = {
  basis.$l.setter$(new $l.callbackClassName$ {
    $l.callbackMethods:unitCallbackMethod(); separator="\n"$
  })
  basis
}
>>

listener(l) ::= <<
$if(l.hasParams)$$fullListener(l)$$endif$

$unitListener(l)$
>>

listeners(cls) ::= <<$cls.listeners:listener(); separator="\n\n"$>>


// property

getter(prop) ::= <<
@inline def $prop.name$ = basis.$prop.getter$
>>

defaultGetter(prop) ::= <<
$if( ! prop.nameClashes)$
@noEquivalentGetterExists
@inline def $prop.name$   : $prop.tpe$  = defaultValue[$prop.tpe$]
$endif$
>>

setters(prop) ::= <<
@inline def $prop.name$  (p: $prop.tpe$) =            $prop.name$_=  (p)
@inline def $prop.name$_=(p: $prop.tpe$) = { basis.$prop.setter$    (p); basis }
>>

property(prop) ::= <<
$if(prop.getter)$$getter(prop)$$else$$defaultGetter(prop)$$endif$
$if(prop.setter)$$setters(prop)$
$endif$
>>

properties(cls) ::= <<$cls.properties:property(); separator="\n"$>>

